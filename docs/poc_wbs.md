# 스팸 필터 시스템 POC WBS

## 개요

본 문서는 기업 메시징 중계 서버 스팸 필터 시스템의 주요 기능 구현에 대한 개념 증명(POC, Proof of Concept)을 위한 작업 분할 구조(WBS)를 제시합니다. 본 POC는 5일 기간 동안 LLM 모델(GPT, Claude, Exaone)과 AI 코딩 어시스턴트를 활용하여 스팸 필터 기능과 성능을 검증하는 것을 목표로 합니다.

## POC 정보

- **프로젝트명**: 스팸 필터 시스템 POC
- **POC 기간**: 총 5일
- **개발 방법론**: 애자일 (일일 스크럼)
- **개발 도구**: Cursor AI 코딩 어시스턴트, Git/GitHub, Docker
- **LLM 모델**: GPT-4, Claude 3, Exaone
- **저장소**: https://github.com/medialog-AX-TF/spam-filter

## POC 목표

1. LightGBM 기반 스팸 필터 모델의 구현 가능성 검증
2. 10ms 이내 처리 시간 요구사항 달성 가능성 검증
3. 1000 TPS 처리량 요구사항 달성 가능성 검증
4. 다양한 LLM 모델을 활용한 스팸 필터링 성능 비교
5. AI 코딩 어시스턴트를 활용한 개발 생산성 향상 검증

## POC WBS 구조

### 1일차: POC 준비 및 데이터 구성

| ID | 작업명 | 시간 | 담당자 | LLM/AI 어시스턴트 활용 방안 |
|----|-------|------|-------|------------------------|
| 1.1 | POC 킥오프 및 목표 설정 | 1시간 | POC 리더, 전체 팀 | 목표 정의 및 문서화 지원 |
| 1.2 | 개발 환경 구축 | 2시간 | 개발자 | 개발 환경 설정 스크립트 생성 |
| 1.3 | 테스트 데이터셋 수집 | 3시간 | 데이터 엔지니어 | 데이터 소스 추천 및 수집 스크립트 작성 |
| 1.4 | 데이터 전처리 파이프라인 구현 | 4시간 | ML 엔지니어 | 전처리 코드 생성 및 최적화 |
| 1.5 | 일일 리뷰 및 계획 조정 | 1시간 | POC 리더, 전체 팀 | 진행 상황 요약 및 다음 날 계획 수립 |

#### 1일차 산출물
- 개발 환경 설정 완료
- 테스트 데이터셋 (최소 10,000건의 레이블된 메시지)
- 데이터 전처리 파이프라인

### 2일차: 모델 구현 및 비교

| ID | 작업명 | 시간 | 담당자 | LLM/AI 어시스턴트 활용 방안 |
|----|-------|------|-------|------------------------|
| 2.1 | LightGBM 모델 구현 | 3시간 | ML 엔지니어 | 모델 코드 작성 및 디버깅 |
| 2.2 | GPT 기반 스팸 필터 구현 | 2시간 | ML 엔지니어 | GPT API 연동 코드 작성 |
| 2.3 | Claude 기반 스팸 필터 구현 | 2시간 | ML 엔지니어 | Claude API 연동 코드 작성 |
| 2.4 | Exaone 기반 스팸 필터 구현 | 2시간 | ML 엔지니어 | Exaone API 연동 코드 작성 |
| 2.5 | 일일 리뷰 및 계획 조정 | 1시간 | POC 리더, 전체 팀 | 진행 상황 요약 및 다음 날 계획 수립 |

#### 2일차 산출물
- LightGBM 기반 스팸 필터 모델
- GPT, Claude, Exaone 기반 스팸 필터 모델
- 각 모델의 초기 성능 지표

### 3일차: 성능 최적화 및 벤치마킹

| ID | 작업명 | 시간 | 담당자 | LLM/AI 어시스턴트 활용 방안 |
|----|-------|------|-------|------------------------|
| 3.1 | LightGBM 모델 최적화 | 3시간 | ML 엔지니어, 성능 엔지니어 | 최적화 기법 적용 및 코드 개선 |
| 3.2 | LLM 프롬프트 최적화 | 2시간 | ML 엔지니어 | 효과적인 프롬프트 설계 지원 |
| 3.3 | 처리 시간 벤치마킹 | 2시간 | 성능 엔지니어 | 벤치마킹 코드 작성 및 결과 분석 |
| 3.4 | 정확도 벤치마킹 | 2시간 | ML 엔지니어 | 평가 지표 계산 및 시각화 코드 작성 |
| 3.5 | 일일 리뷰 및 계획 조정 | 1시간 | POC 리더, 전체 팀 | 진행 상황 요약 및 다음 날 계획 수립 |

#### 3일차 산출물
- 최적화된 LightGBM 모델 (10ms 이내 처리 목표)
- 최적화된 LLM 프롬프트
- 성능 벤치마킹 결과 (처리 시간, 정확도, 오탐률)

### 4일차: 시스템 통합 및 부하 테스트

| ID | 작업명 | 시간 | 담당자 | LLM/AI 어시스턴트 활용 방안 |
|----|-------|------|-------|------------------------|
| 4.1 | 간소화된 API 서버 구현 | 3시간 | 백엔드 개발자 | API 서버 코드 작성 |
| 4.2 | 모델 서빙 시스템 구현 | 3시간 | ML 엔지니어, 백엔드 개발자 | 모델 서빙 코드 작성 및 최적화 |
| 4.3 | Docker 컨테이너화 | 2시간 | DevOps 엔지니어 | Dockerfile 및 docker-compose.yml 작성 |
| 4.4 | 부하 테스트 (1000 TPS) | 3시간 | 성능 엔지니어 | 부하 테스트 스크립트 작성 및 결과 분석 |
| 4.5 | 일일 리뷰 및 계획 조정 | 1시간 | POC 리더, 전체 팀 | 진행 상황 요약 및 다음 날 계획 수립 |

#### 4일차 산출물
- 간소화된 API 서버
- 모델 서빙 시스템
- Docker 컨테이너
- 부하 테스트 결과 (1000 TPS 목표)

### 5일차: 결과 분석 및 문서화

| ID | 작업명 | 시간 | 담당자 | LLM/AI 어시스턴트 활용 방안 |
|----|-------|------|-------|------------------------|
| 5.1 | 모델 성능 비교 분석 | 2시간 | ML 엔지니어 | 성능 데이터 분석 및 시각화 |
| 5.2 | 시스템 성능 분석 | 2시간 | 성능 엔지니어 | 시스템 성능 데이터 분석 및 시각화 |
| 5.3 | POC 결과 보고서 작성 | 3시간 | POC 리더, 기술 작가 | 보고서 초안 작성 및 편집 |
| 5.4 | 향후 개발 계획 수립 | 2시간 | POC 리더, 아키텍트 | 개발 계획 수립 지원 |
| 5.5 | POC 결과 발표 준비 및 진행 | 2시간 | POC 리더, 전체 팀 | 발표 자료 작성 지원 |

#### 5일차 산출물
- 모델 성능 비교 분석 보고서
- 시스템 성능 분석 보고서
- POC 결과 보고서
- 향후 개발 계획

## 모델별 검증 항목

### LightGBM 모델
- 정확도 (목표: 90% 이상)
- 처리 시간 (목표: 10ms 이내)
- 오탐률 (목표: 5% 이하)
- 메모리 사용량
- 모델 크기

### GPT 기반 모델
- 정확도 (목표: 95% 이상)
- 처리 시간 (API 호출 포함)
- 오탐률
- API 비용 추정
- 프롬프트 최적화 효과

### Claude 기반 모델
- 정확도 (목표: 95% 이상)
- 처리 시간 (API 호출 포함)
- 오탐률
- API 비용 추정
- 프롬프트 최적화 효과

### Exaone 기반 모델
- 정확도 (목표: 95% 이상)
- 처리 시간 (API 호출 포함)
- 오탐률
- API 비용 추정
- 프롬프트 최적화 효과

## LLM 모델 활용 전략

### 1. 데이터 전처리 및 특성 엔지니어링
- 텍스트 전처리 파이프라인 설계
- 효과적인 특성 추출 방법 제안
- 데이터 증강 기법 제안

### 2. 모델 구현 및 최적화
- LightGBM 모델 구현 코드 작성
- 하이퍼파라미터 튜닝 전략 제안
- 모델 최적화 기법 적용

### 3. LLM 기반 스팸 필터링
- 효과적인 프롬프트 설계
- Few-shot 학습 예제 생성
- 결과 해석 및 분류 로직 구현

### 4. 성능 평가 및 분석
- 평가 지표 계산 코드 작성
- 결과 시각화 및 해석
- 모델 간 성능 비교 분석

### 5. 문서화 및 보고서 작성
- 기술 문서 초안 작성
- 코드 주석 및 설명 추가
- 결과 보고서 작성 지원

## AI 코딩 어시스턴트 활용 전략

### 1. 코드 생성 및 최적화
- 데이터 전처리 코드 생성
- 모델 구현 코드 작성
- API 서버 및 모델 서빙 코드 작성
- 성능 최적화 코드 제안

### 2. 테스트 및 디버깅
- 단위 테스트 코드 작성
- 성능 테스트 스크립트 작성
- 오류 디버깅 및 해결 방안 제시

### 3. 문서화 및 시각화
- 코드 문서화 및 주석 추가
- 결과 시각화 코드 작성
- 보고서 초안 작성 지원

## 리스크 관리

| 리스크 | 영향 | 확률 | 대응 전략 |
|-------|------|------|----------|
| 데이터셋 품질 문제 | 높음 | 중간 | 다양한 소스에서 데이터 수집, 데이터 품질 검증 강화 |
| 10ms 처리 시간 미달성 | 높음 | 중간 | 추가 최적화 기법 적용, 모델 경량화 |
| 1000 TPS 처리량 미달성 | 높음 | 중간 | 병렬 처리 구현, 캐싱 전략 적용 |
| LLM API 응답 지연 | 중간 | 높음 | 타임아웃 설정, 폴백 메커니즘 구현 |
| 개발 환경 설정 문제 | 중간 | 낮음 | Docker 컨테이너 활용, 환경 설정 자동화 |

## POC 팀 구성

| 역할 | 인원 수 | 주요 책임 |
|------|--------|----------|
| POC 리더 | 1 | POC 계획 및 관리, 결과 보고서 작성 |
| ML 엔지니어 | 1 | 모델 구현 및 최적화, LLM 프롬프트 설계 |
| 백엔드 개발자 | 1 | API 서버 및 모델 서빙 시스템 구현 |
| 성능 엔지니어 | 1 | 성능 최적화 및 벤치마킹, 부하 테스트 |
| 데이터 엔지니어 | 1 | 데이터 수집 및 전처리 |

## 결론

본 POC WBS는 5일 동안 스팸 필터 시스템의 주요 기능과 성능을 검증하기 위한 작업 계획을 제시합니다. LLM 모델(GPT, Claude, Exaone)과 AI 코딩 어시스턴트를 적극 활용하여 개발 생산성을 높이고, 다양한 접근 방식의 성능을 비교 분석할 수 있을 것으로 기대됩니다. 이 POC를 통해 스팸 필터 시스템의 구현 가능성과 성능 요구사항 달성 가능성을 검증하고, 향후 전체 프로젝트 개발을 위한 중요한 인사이트를 얻을 수 있을 것입니다. 